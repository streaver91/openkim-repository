#!/usr/bin/env python
"""
Vacancy Migration Energy (VME) and Formation Energy (VFE) Test Driver
Works for Both Cubic and HCP Crystals, at 0 K and 0 GPa

This test driver first calculates VME and VFE of several fixed size supercell
and extrapolate these results to obtain the dilute limit.
VME is calculated by nudged elastic band method.

Date: 2015/09/17
Author: Junhao Li <streaver91@gmail.com>
"""
# ASE Modules
import ase
try:
    from ase.lattice import bulk
    print 'Imported bulk from ase.lattice' # For ASE version 3.9
except ImportError:
    from ase.structure import bulk
    print 'Imported bulk from ase.structure' # For ASE version <= 3.8
from ase.optimize import FIRE, QuasiNewton, MDMin
from ase.data import chemical_symbols
from ase.data import reference_states
from ase import Atoms, Atom
from ase.io import write
from ase.constraints import FixAtoms
from ase.neb import NEB

# KIM Modules
from kimcalculator import *
from kimservice import KIM_API_get_data_double

# Python Modules
from scipy.optimize import fmin
from scipy.interpolate import interp1d
import numpy as np
import sys
import re
import json
import math
from collections import OrderedDict

# Parameters for Production
FIRE_LOG = 'fire.log'
FIRE_MAX_STEPS = 500
FIRE_TOL = 1e-6 # absolute
FMIN_FTOL = 1e-6 # relative
FMIN_XTOL = 1e-10 # relative
VFE_TOL = 1e-5 # absolute
CELL_SIZE_MIN = 3
CELL_SIZE_MAX = 5
COLLAPSE_CRITERIA_VOLUME = 0.1
COLLAPSE_CRITERIA_ENERGY = 0.1
DYNAMIC_CELL_SIZE = True # Increase Cell Size According to lattice structure
MDMIN_TOL = 5e-2
NEB_POINTS = 10

# Parameters for Debugging
# FIRE_MAX_STEPS = 200
FIRE_TOL = 1e-2 # absolute
# FMIN_FTOL = 1e-3 # relative
# FMIN_XTOL = 1e-5 # relative

# Extrapolation Parameters
FITS_CNT = [2, 3] # Number of data points used for each fitting
FITS_ORDERS = [
    [0, 3],
    [0, 3],
] # Number of orders included in each fitting
# Fit Results Used (Corresponding to the above)
FITS_VFE_VALUE = 0 # Vacancy Formation Energy
FITS_VFE_UNCERT = [1]
FITS_VME_VALUE = 0 # Vacancy Relaxation Volume
FITS_VME_UNCERT = [1]

# Strings for Output
KEY_SOURCE_VALUE = 'source-value'
KEY_SOURCE_UNIT = 'source-unit'
KEY_SOURCE_UNCERT = 'source-std-uncert-value'
UNIT_ENERGY = 'eV'
UNIT_LENGTH = 'angstrom'
UNIT_ANGLE = 'degree'
UNIT_PRESSURE = 'GPa'
UNIT_VOLUME = UNIT_LENGTH + '^3'
SPACE_GROUPS = {
    'fcc': 'Fm-3m',
    'bcc': 'Im-3m', 
    'sc': 'Pm-3m', 
    'diamond': 'Fd-3m', 
    'hcp': 'P63/mmc',
}
WYCKOFF_CODES = {
    'fcc': ['4a'], 
    'bcc': ['2a'], 
    'sc': ['1a'], 
    'diamond': ['8a'], 
    'hcp': ['2d'],
}
WYCKOFF_SITES = {
    'fcc': [[0.0, 0.0, 0.0]],
    'bcc': [[0.0, 0.0, 0.0]],
    'sc': [[0.0, 0.0, 0.0]],
    'diamond': [[0.0, 0.0, 0.0]],
    'hcp': [[2.0 / 3.0, 1.0 / 3.0, 0.25]],
}
VFE_PROP_ID = 'tag:staff@noreply.openkim.org,2015-07-28:property/monovacancy-neutral-relaxed-formation-potential-energy-crystal-npt'
VME_PROP_ID = 'tag:staff@noreply.openkim.org,2015-09-16:property/monovacancy-neutral-migration-energy-crystal-npt'
VRV_PROP_ID = 'tag:staff@noreply.openkim.org,2015-07-28:property/monovacancy-neutral-migration-energy-crystal-npt'

# Obtain Inputs
elem = raw_input()
lattice = raw_input()
model = raw_input()
latticeConstA = raw_input()
latticeConstC = raw_input()

# Inputs for Debugging
# elem  = 'Ni'
# lattice = 'hcp'
# model   = 'EAM_Dynamo_Mishin_Farkas_Ni__MO_400591584784_001'
# latticeConstA = '1.6043141589847716'
# latticeConstC = '4.215631487401131'

# elem  = 'Al'
# lattice = 'fcc'
# model   = 'EAM_Dynamo_Mishin_Farkas_Al__MO_651801486679_001'
# latticeConstA = '4.0500047'
# latticeConstC = '[]'

# elem = 'Al'
# lattice = 'diamond'
# model = 'EAM_Dynamo_Mendelev_Kramer_Al__MO_106969701023_001'
# latticeConstA = '5.78674789518'

# elem  = 'Al'
# lattice = 'hcp'
# model   = 'EAM_Dynamo_Mishin_Farkas_Al__MO_651801486679_001'
# latticeConstA = '2.81911283749921'
# latticeConstC = '4.9445070765705639'

# elem = 'Cr'
# lattice = 'bcc'
# model = 'Pair_Morse_Shifted_GirifalcoWeizer_HighCutoff_Cr__MO_859700307573_001'
# latticeConstA = '2.8755436e'

# elem = 'Ni'
# lattice = 'fcc'
# model = 'EAM_Dynamo_Mishin_Farkas_Ni__MO_400591584784_001'
# latticeConstA = '3.5199995'

# elem = 'Si'
# lattice = 'diamond'
# model = 'Three_Body_Stillinger_Weber_Si__MO_405512056662_001'
# latticeConstA = '5.43094978468'

class VacancyCalculation(object):
    # Class for calculating vacancy formation energy and relaxation volume
    def __init__(self, calc, elem, model, lattice, latticeConsts):
        self.calc = calc
        self.elem = elem
        self.model = model
        self.lattice = lattice
        self.latticeConsts = latticeConsts
        if lattice == 'hcp':
            atoms = bulk(
                elem,
                a = latticeConsts[0],
                c = latticeConsts[1],
                crystalstructure = 'hcp',
            )
        else:
            atoms = bulk(
                elem, 
                a = latticeConsts[0], 
                crystalstructure = lattice, 
                cubic = True,
            )
        atoms.set_calculator(calc)
        self.atoms = atoms
        
        # Determine size of the supercell
        if DYNAMIC_CELL_SIZE == True:
            nAtoms = atoms.get_number_of_atoms()
            factor = math.pow(8 / nAtoms, 0.333)
            self.cellSizeMin = int(math.ceil(factor * CELL_SIZE_MIN))
            self.cellSizeMax = self.cellSizeMin + 2
            print 'Cell Size Min:', self.cellSizeMin
            print 'Cell Size Max:', self.cellSizeMax
            print 'Smallest System Size:', nAtoms * self.cellSizeMin**3
            print 'Largest System Size:', nAtoms * self.cellSizeMax**3
            print 'Model Cutoff:', KIM_API_get_data_double(calc.pkim, 'cutoff')[0]
    
    def _createSupercell(self, size):
        superAtoms = self.atoms.copy()
        superAtoms.set_calculator(self.calc)
        superAtoms *= (size, size, size)
        return superAtoms
    
    def _getResultsForSize(self, size):
        print 'Calculating Size', size, '...'
        atoms = self._createSupercell(size)
        enAtoms = atoms.get_potential_energy()
        nAtoms = atoms.get_number_of_atoms()
        removedAtomPosition = atoms.get_positions()[0]
        del atoms[0]
        
        # Get Initial State
        initial = atoms.copy()
        initial.set_calculator(self.calc)
        dyn = FIRE(initial, logfile = FIRE_LOG)
        dyn.run(fmax = FIRE_TOL, steps = FIRE_MAX_STEPS)
        
        # Get Final State
        tmpPositions = atoms.get_positions()
        tmpPositions[0] = removedAtomPosition
        atoms.set_positions(tmpPositions)
        final = atoms.copy()
        final.set_calculator(self.calc)
        dyn = FIRE(final, logfile = FIRE_LOG)
        dyn.run(fmax = FIRE_TOL, steps = FIRE_MAX_STEPS)
        
        # Calculate VFE
        enInitial = initial.get_potential_energy()
        formationEnergy = enInitial - enAtoms * (nAtoms - 1) / nAtoms
        
        # Calculate VME
        # Apply NEB
        images = [initial]
        for i in range(NEB_POINTS):
            images.append(initial.copy())
        images.append(final)
        for image in images:
            image.set_calculator(KIMCalculator(self.model))
        neb = NEB(images)
        neb.interpolate()
        minimizer = MDMin(neb)
        minimizer.run(fmax = MDMIN_TOL)
        potentials = []
        for image in images:
            potentials.append(image.get_potential_energy())
        
        # Spline Interpolation
        x = np.arange(0, NEB_POINTS + 2)
        y = np.array(potentials)
        f = interp1d(x, -y, kind = 'cubic')
        xmax = fmin(f, x[NEB_POINTS / 2 + 1])
        ymax = f(xmax)
        enSaddle = -ymax[0]
        migrationEnergy = enSaddle - enInitial
        
        # Output Results
        print 'Formation Energy:', formationEnergy
        print 'Migration Energy:', migrationEnergy
        return migrationEnergy, formationEnergy
    
    def _getUnitVector(self, vec):
        return vec / np.linalg.norm(vec)
        
    def _getAngle(self, vec1, vec2):
        # Get acute angle between two vectors in degrees (always between 0 - 90)
        vec1Unit = self._getUnitVector(vec1)
        vec2Unit = self._getUnitVector(vec2)
        angle = np.arccos(np.dot(vec1Unit, vec2Unit))
        if np.isnan(angle):
            return 0.0
        angle = angle * 180.0 / np.pi
        # if angle < 0:
            # return 180.0 + angle
        return angle
        
    def _getFit(self, xdata, ydata, orders):
        # Polynomial Fitting with Specific Orders
        A = []
        print '\nFit with Size:', xdata
        print 'Orders:', orders
        for order in orders:
            A.append(np.power(xdata * 1.0, -order))
        A = np.vstack(A).T
        print 'Matrix A (Ax = y):\n', A
        print 'Data for Fitting:', ydata
        res = np.linalg.lstsq(A, ydata)
        print 'Fitting Results:', res
        return res[0]
    
    def _extrapolate(self, sizes, valueBySize, valueFitId, uncertFitsId, systemUncert):
        # Extrapolate to Obtain VFE and VME of Infinite Size
        naSizes = np.array(sizes)
        naValueBySize = np.array(valueBySize)
        valueFitsBySize = []
        for i in range(len(FITS_CNT)):
            cnt = FITS_CNT[i]
            orders = FITS_ORDERS[i]
            print 'Fitting w/', cnt, 'points, including orders', orders
            valueFits = []
            for j in range(0, len(sizes) - cnt + 1):
                xdata = naSizes[j:(j + cnt)]
                valueFits.append(self._getFit(
                    xdata, 
                    valueBySize[j:(j + cnt)], 
                    orders
                )[0])
            valueFitsBySize.append(valueFits)
        
        # Get Source Value
        valueFitCnt = FITS_CNT[valueFitId]
        maxSizeId = len(sizes) - 1
        sourceValue = valueFitsBySize[valueFitId][maxSizeId - valueFitCnt + 1]
        
        # Get Source Uncertainty (Statistical)
        sourceUncert = 0
        for uncertFitId in uncertFitsId:
            uncertFitCnt = FITS_CNT[uncertFitId]
            uncertValue = valueFitsBySize[uncertFitId][maxSizeId - uncertFitCnt + 1]
            sourceUncert = max([abs(uncertValue - sourceValue), sourceUncert])
        
        # Include systematic error, assuming independent of statistical errors
        sourceUncert = math.sqrt(sourceUncert**2 + systemUncert**2)
        return sourceValue, sourceUncert
    
    def _getCrystalInfo(self):
        unitBulk = self.atoms
        unitCell = unitBulk.get_cell()
        hostInfo = OrderedDict([
            ('host-cauchy-stress', V([0, 0, 0, 0, 0, 0], UNIT_PRESSURE)),
            ('host-short-name', V([self.lattice])),
            ('host-a', V(np.linalg.norm(unitCell[0]), UNIT_LENGTH)),
            ('host-b', V(np.linalg.norm(unitCell[1]), UNIT_LENGTH)),
            ('host-c', V(np.linalg.norm(unitCell[2]), UNIT_LENGTH)),
            ('host-alpha', V(self._getAngle(unitCell[1], unitCell[2]), UNIT_ANGLE)),
            ('host-beta', V(self._getAngle(unitCell[2], unitCell[0]), UNIT_ANGLE)),
            ('host-gamma', V(self._getAngle(unitCell[0], unitCell[1]), UNIT_ANGLE)),
            ('host-space-group', V(SPACE_GROUPS[self.lattice])),
            ('host-wyckoff-multiplicity-and-letter', V(WYCKOFF_CODES[self.lattice])),
            ('host-wyckoff-coordinates', V(WYCKOFF_SITES[self.lattice])),
            ('host-wyckoff-species', V([self.elem] * len(WYCKOFF_CODES[self.lattice]))),
        ])
        reservoirInfo = OrderedDict([
            ('reservoir-cohesive-potential-energy', V(unitBulk.get_potential_energy(), UNIT_ENERGY)),
            ('reservoir-short-name', V([self.lattice])),
            ('reservoir-cauchy-stress', V([0.0, 0.0, 0.0, 0.0, 0.0, 0.0], UNIT_PRESSURE)),
            ('reservoir-a', V(np.linalg.norm(unitCell[0]), UNIT_LENGTH)),
            ('reservoir-b', V(np.linalg.norm(unitCell[1]), UNIT_LENGTH)),
            ('reservoir-c', V(np.linalg.norm(unitCell[2]), UNIT_LENGTH)),
            ('reservoir-alpha', V(self._getAngle(unitCell[1], unitCell[2]), UNIT_ANGLE)),
            ('reservoir-beta', V(self._getAngle(unitCell[2], unitCell[0]), UNIT_ANGLE)),
            ('reservoir-gamma', V(self._getAngle(unitCell[0], unitCell[1]), UNIT_ANGLE)),
            ('reservoir-space-group', V(SPACE_GROUPS[self.lattice])),
            ('reservoir-wyckoff-multiplicity-and-letter', V(WYCKOFF_CODES[self.lattice])),
            ('reservoir-wyckoff-coordinates', V(WYCKOFF_SITES[self.lattice])),
            ('reservoir-wyckoff-species', V([self.elem] * len(WYCKOFF_CODES[self.lattice]))),
        ])
        return hostInfo, reservoirInfo
    
    def getResults(self):
        
        # Calculate VME and VFE for Each Size
        # sizes = []
        # migrationEnergyBySize = []
        # formationEnergyBySize = []
        # print '\n[Calculation]'
        # for size in range(self.cellSizeMin, self.cellSizeMax + 1):
            # migrationEnergy, formationEnergy = self._getResultsForSize(size)
            # sizes.append(size)
            # migrationEnergyBySize.append(migrationEnergy)
            # formationEnergyBySize.append(formationEnergy)
        
        # For debug
        sizes = [4, 5, 6]
        migrationEnergyBySize = [
            0.64576855097573116,
            0.64448594514897195,
            0.64412217147128104,
        ]
        formationEnergyBySize = [
            0.67914728564926463,
            0.67877480646416188,
            0.67873178748595819,
        ]
        
        print '\n[Calculation Results Summary]'
        print 'Size\tMigrationEnergy\tFormationEnergy'
        for i in range(len(sizes)):
            print [sizes[i], migrationEnergyBySize[i], formationEnergyBySize[i]]
        
        # Extrapolate for VFE and VME of Infinite Size
        print '\n[Extrapolation]'
        VMEValue, VMEUncert = self._extrapolate(
            sizes,
            migrationEnergyBySize,
            FITS_VME_VALUE,
            FITS_VME_UNCERT,
            math.sqrt(FIRE_TOL**2 + MDMIN_TOL**2),
        )
        VFEValue, VFEUncert = self._extrapolate(
            sizes,
            formationEnergyBySize,
            FITS_VFE_VALUE,
            FITS_VFE_UNCERT,
            FIRE_TOL,
        )
        
        print [VMEValue, VMEUncert]
        print [VFEValue, VFEUncert]
        
        migrationEnergyResult = OrderedDict([
            ('property-id', VME_PROP_ID),
            ('instance-id', 1),
            ('vacancy-migration-energy', V(VMEValue, UNIT_ENERGY, VMEUncert)),
            ('host-missing-atom-start', V(1)),
            ('host-missing-atom-end', V(1)),
        ])
        formationEnergyResult = OrderedDict([
            ('property-id', VFE_PROP_ID),
            ('instance-id', 2),
            ('relaxed-formation-potential-energy', V(VFEValue, UNIT_ENERGY, VFEUncert)),
            ('host-removed-atom', V(1)),
        ])
        hostInfo, reservoirInfo = self._getCrystalInfo()
        migrationEnergyResult.update(hostInfo)
        formationEnergyResult.update(hostInfo)
        formationEnergyResult.update(reservoirInfo)
        results = [migrationEnergyResult, formationEnergyResult]
        return results

def V(value, unit = '', uncert = ''):
    # Generate OrderedDict for JSON Dump
    res = OrderedDict([
        (KEY_SOURCE_VALUE, value),
    ])
    if unit != '':
        res.update(OrderedDict([
            (KEY_SOURCE_UNIT, unit),
        ]))
    if uncert != '':
        res.update(OrderedDict([
            (KEY_SOURCE_UNCERT, uncert)
        ]))
    return res

def main():
    # Create Environment and Common Variables
    # If it's hcp crystal, process both a and c
    # Otherwise, process a, ignore c
    if lattice == 'hcp':
        latticeConsts = [float(latticeConstA), float(latticeConstC)]
    else:
        latticeConsts = [float(latticeConstA)]
    calc = KIMCalculator(model)
    print 'Parameters Input:', elem, lattice, model, latticeConsts
    
    # Create Instance
    instance = VacancyCalculation(calc, elem, model, lattice, latticeConsts)
    
    # Obtain Results
    res = instance.getResults()
    
    # Output results
    print '\n[Final Results]'
    resStr = json.dumps(res, separators = (' ',' '), indent = 4)
    print resStr
    with open(os.path.abspath('output/results.edn'), 'w') as f:
        f.write(resStr)

if __name__ == '__main__':
    main()