#!/usr/bin/env python
"""
Vacancy Migration Energy (VME) and Formation Energy (VFE) Test Driver
Works for Both Cubic and HCP Crystals, at 0 K and 0 GPa

This test driver first calculates VFE and VME of several fixed size supercells,
then extrapolates these results to obtain the dilute limit. VME is calculated
with nudged elastic band method.

2016-04-06 Junhao Li <streaver91@gmail.com>
* change the output format to conform with the new property definition.
* add the calculation of relaxation volume and elastic multipoles.
* change the version number to 001

Author: Junhao Li <streaver91@gmail.com>
"""
# Python Modules
import sys
import re
import json
import os
import re

# Vacancy Driver Modules
import config as C
import functions as F
from vacancy import Vacancy

# Generate OrderedDict for all properties to report
def packResult(res):
    print '[Packing results]'
    instanceId = 1 # Instance id start from 1
    driverPath = os.path.dirname(os.path.abspath(__file__))
    instances = []
    # Loop through each property definition
    for pd in C.PROPERTY_DEFINITIONS:
        print 'packing results for: ' + pd
        instance = {
            'instance-id': instanceId
        }
        with open(driverPath + ('/definitions/%s.edn' % pd), 'r') as f:
            content = f.read()
            # Obtain property id
            tmp = re.search('property-id\" \"([^\"]+)\"', content, re.M)
            propertyId = tmp.group(1)
            instance['property-id'] = propertyId
            # Obtain property keys
            tmp = re.findall('\"([^\"]+)\" \{', content)
            for prop in tmp:
                resKey = prop # corresponding key in res object
                if prop[:5] == 'host-':
                    resKey = prop[5:]
                elif prop[:10] == 'reservoir-':
                    resKey = prop[10:]
                if resKey in res:
                    instance[prop] = res[resKey]
                else:
                    print 'missing:', prop
        if C.OUTPUT_INSTANCES:
            print 'results:'
            F.printDict(instance)
        instances.append(instance)
        instanceId += 1
    return instances

def printKeyConfig():
    print '[Config]'
    print 'FMAX_TOL:', C.FMAX_TOL
    print 'NEB_POINTS:', C.NEB_POINTS
    print 'MIN_ATOMS:', C.MIN_ATOMS
    print 'NUM_SIZES:', C.NUM_SIZES

def main():
    printKeyConfig()
    # Obtain raw inputs
    elem = raw_input()
    lattice = raw_input()
    model = raw_input()
    latticeConstA = raw_input()
    latticeConstC = raw_input()

    # If it's hcp crystal, process both a and c
    # Otherwise, process a only
    if lattice == 'hcp':
        latticeConsts = [float(latticeConstA), float(latticeConstC)]
    else:
        latticeConsts = [float(latticeConstA)]

    # Create Instance
    migration = C.MIGRATION
    vacancy = Vacancy(elem, model, lattice, latticeConsts, migration)

    # Obtain Results and pack them into required format
    vacancy.run()
    res = vacancy.getResult()
    instances = packResult(res)

    # Output results
    insEdn = json.dumps(instances, separators = (' ',' '), indent = 2)
    with open(os.path.abspath('output/results.edn'), 'w') as f:
        f.write(insEdn)
    if C.SAVE_JSON:
        res['info'] = {
            'model': model,
            'lattice': lattice,
            'elem': elem,
            'fmax': C.FMAX_TOL,
            'neb-points': C.NEB_POINTS,
            'num-sizes': C.NUM_SIZES,
            'min-atoms': C.MIN_ATOMS
        }
        resJson = json.dumps(res, indent = 2)
        with open(os.path.abspath('output/summary.json'), 'w') as f:
            f.write(resJson)

    F.clock('test completed')

if __name__ == '__main__':
    main()
