#!/usr/bin/env python
"""
Vacancy Migration Energy (VME) and Formation Energy (VFE) Test Driver
Works for Both Cubic and HCP Crystals, at 0 K and 0 GPa

This test driver calculates VME and VFE of several fixed size supercell
and extrapolate these results to obtain the dilute limit.
VME is calculated by nudged elastic band method.

Date: 2015/09/17
Author: Junhao Li <streaver91@gmail.com>
"""
# ASE Modules
import ase
try:
    from ase.lattice import bulk
    print 'Imported bulk from ase.lattice' # For ASE version 3.9
except ImportError:
    from ase.structure import bulk
    print 'Imported bulk from ase.structure' # For ASE version <= 3.8
from ase.optimize import FIRE, QuasiNewton, MDMin
from ase.data import chemical_symbols
from ase.data import reference_states
from ase import Atoms, Atom
from ase.io import write
from ase.constraints import FixAtoms
from ase.neb import NEB

# KIM Modules
from kimcalculator import *
from kimservice import KIM_API_get_data_double

# Python Modules
from scipy.optimize import fmin
from scipy.interpolate import interp1d
import numpy as np
import sys
import re
import json
import math
from collections import OrderedDict

# Parameters for Production
FIRE_LOG = 'fire.log'
FIRE_MAX_STEPS = 500
FIRE_TOL = 1e-6 # absolute
FMIN_FTOL = 1e-6 # relative
FMIN_XTOL = 1e-10 # relative
VFE_TOL = 1e-5 # absolute
MAX_LOOPS = 20
CELL_SIZE_MIN = 3
CELL_SIZE_MAX = 5
COLLAPSE_CRITERIA_VOLUME = 0.1
COLLAPSE_CRITERIA_ENERGY = 0.1
DYNAMIC_CELL_SIZE = True # Increase Cell Size According to lattice structure
MDMIN_TOL = 5e-2
NEB_POINTS = 10

# Parameters for Debugging
# FIRE_MAX_STEPS = 200
FIRE_TOL = 1e-2 # absolute
# FMIN_FTOL = 1e-3 # relative
# FMIN_XTOL = 1e-5 # relative

# Extrapolation Parameters
FITS_CNT = [2, 3, 3, 3, 3] # Number of data points used for each fitting
FITS_ORDERS = [
    [0, 3],
    [0, 3],
    [0, 3, 4],
    [0, 3, 5],
    [0, 3, 6],
] # Number of orders included in each fitting
# Fit Results Used (Corresponding to the above)
FITS_VFE_VALUE = 0 # Vacancy Formation Energy
FITS_VFE_UNCERT = [1, 2]
FITS_VRV_VALUE = 0 # Vacancy Relaxation Volume
FITS_VRV_UNCERT = [1, 2]

# Strings for Output
KEY_SOURCE_VALUE = 'source-value'
KEY_SOURCE_UNIT = 'source-unit'
KEY_SOURCE_UNCERT = 'source-std-uncert-value'
UNIT_ENERGY = 'eV'
UNIT_LENGTH = 'angstrom'
UNIT_ANGLE = 'degree'
UNIT_PRESSURE = 'GPa'
UNIT_VOLUME = UNIT_LENGTH + '^3'
SPACE_GROUPS = {
    'fcc': 'Fm-3m',
    'bcc': 'Im-3m', 
    'sc': 'Pm-3m', 
    'diamond': 'Fd-3m', 
    'hcp': 'P63/mmc',
}
WYCKOFF_CODES = {
    'fcc': ['4a'], 
    'bcc': ['2a'], 
    'sc': ['1a'], 
    'diamond': ['8a'], 
    'hcp': ['2d'],
}
WYCKOFF_SITES = {
    'fcc': [[0.0, 0.0, 0.0]],
    'bcc': [[0.0, 0.0, 0.0]],
    'sc': [[0.0, 0.0, 0.0]],
    'diamond': [[0.0, 0.0, 0.0]],
    'hcp': [[2.0 / 3.0, 1.0 / 3.0, 0.25]],
}
VFE_PROP_ID = 'tag:staff@noreply.openkim.org,2015-07-28:property/monovacancy-neutral-relaxed-formation-potential-energy-crystal-npt'
VRV_PROP_ID = 'tag:staff@noreply.openkim.org,2015-07-28:property/monovacancy-neutral-migration-energy-crystal-npt'

# Obtain Inputs
# elem = raw_input()
# lattice = raw_input()
# model = raw_input()
# latticeConstA = raw_input()
# latticeConstC = raw_input()

# Inputs for Debugging
# elem  = 'Ni'
# lattice = 'hcp'
# model   = 'EAM_Dynamo_Mishin_Farkas_Ni__MO_400591584784_001'
# latticeConstA = '1.6043141589847716'
# latticeConstC = '4.215631487401131'

elem  = 'Al'
lattice = 'fcc'
model   = 'EAM_Dynamo_Mishin_Farkas_Al__MO_651801486679_001'
latticeConstA = '4.0500047'
latticeConstC = '[]'

# elem = 'Al'
# lattice = 'diamond'
# model = 'EAM_Dynamo_Mendelev_Kramer_Al__MO_106969701023_001'
# latticeConstA = '5.78674789518'

# elem  = 'Al'
# lattice = 'hcp'
# model   = 'EAM_Dynamo_Mishin_Farkas_Al__MO_651801486679_001'
# latticeConstA = '2.81911283749921'
# latticeConstC = '4.9445070765705639'

# elem = 'Cr'
# lattice = 'bcc'
# model = 'Pair_Morse_Shifted_GirifalcoWeizer_HighCutoff_Cr__MO_859700307573_001'
# latticeConstA = '2.8755436e'

# elem = 'Ni'
# lattice = 'fcc'
# model = 'EAM_Dynamo_Mishin_Farkas_Ni__MO_400591584784_001'
# latticeConstA = '3.5199995'

# elem = 'Si'
# lattice = 'diamond'
# model = 'Three_Body_Stillinger_Weber_Si__MO_405512056662_001'
# latticeConstA = '5.43094978468'

class VacancyCalculation(object):
    # Class for calculating vacancy formation energy and relaxation volume
    def __init__(self, calc, elem, model, lattice, latticeConsts):
        self.calc = calc
        self.elem = elem
        self.model = model
        self.lattice = lattice
        self.latticeConsts = latticeConsts
        if lattice == 'hcp':
            atoms = bulk(
                elem,
                a = latticeConsts[0],
                c = latticeConsts[1],
                crystalstructure = 'hcp',
            )
        else:
            atoms = bulk(
                elem, 
                a = latticeConsts[0], 
                crystalstructure = lattice, 
                cubic = True,
            )
        atoms.set_calculator(calc)
        self.atoms = atoms
        if DYNAMIC_CELL_SIZE == True:
            nAtoms = atoms.get_number_of_atoms()
            factor = math.pow(8 / nAtoms, 0.333)
            self.cellSizeMin = int(math.ceil(factor * CELL_SIZE_MIN))
            self.cellSizeMax = self.cellSizeMin + 2
            print 'Cell Size Min:', self.cellSizeMin
            print 'Cell Size Max:', self.cellSizeMax
            print 'Smallest System Size:', nAtoms * self.cellSizeMin**3
            print 'Largest System Size:', nAtoms * self.cellSizeMax**3
            print 'Model Cutoff:', KIM_API_get_data_double(calc.pkim, 'cutoff')[0]
    
    def _createSupercell(self, size):
        superAtoms = self.atoms.copy()
        superAtoms.set_calculator(self.calc)
        superAtoms *= (size, size, size)
        return superAtoms
    
    # def _getVFE(self, cellVector, atoms, enAtoms, numAtoms):
        # newCell = self._cellVector2Cell(cellVector)
        # atoms.set_cell(newCell, scale_atoms = True)
        # enAtomsWithVacancy = atoms.get_potential_energy()
        # enVacancy = enAtomsWithVacancy - enAtoms * (numAtoms - 1) / numAtoms
        # return enVacancy
    
    def _getResultsForSize(self, size):
        print 'Calculating Size', size, '...'
        atoms = self._createSupercell(size)
        enAtoms = atoms.get_potential_energy()
        nAtoms = atoms.get_number_of_atoms()
        removedAtomPosition = atoms.get_positions()[0]
        del atoms[0]
        
        # Get Initial State
        initial = atoms.copy()
        initial.set_calculator(self.calc)
        dyn = FIRE(initial, logfile = FIRE_LOG)
        dyn.run(fmax = FIRE_TOL, steps = FIRE_MAX_STEPS)
        
        # Get Final State
        tmpPositions = atoms.get_positions()
        tmpPositions[0] = removedAtomPosition
        atoms.set_positions(tmpPositions)
        final = atoms.copy()
        final.set_calculator(self.calc)
        dyn = FIRE(final, logfile = FIRE_LOG)
        dyn.run(fmax = FIRE_TOL, steps = FIRE_MAX_STEPS)
        
        # Calculate VFE
        enInitial = initial.get_potential_energy()
        formationEnergy = enInitial - enAtoms * (nAtoms - 1) / nAtoms
        print formationEnergy
        
        # Calculate VME
        images = [initial]
        for i in range(NEB_POINTS):
            images.append(initial.copy())
        images.append(final)
        
        for image in images:
            image.set_calculator(KIMCalculator(self.model))
        
        neb = NEB(images)
        neb.interpolate()
        
        minimizer = MDMin(neb)
        minimizer.run(fmax = MDMIN_TOL)
        
        potentials = []
        for image in images:
            potentials.append(image.get_potential_energy())
        
        # Spline Interpolation
        x = np.arange(0, NEB_POINTS + 2)
        y = np.array(potentials)
        print x
        print y
        f = interp1d(x, -y, kind = 'cubic')
        xmax = fmin(f, x[NEB_POINTS / 2 + 1])
        ymax = f(xmax)
        enSaddle = -ymax[0]
        migrationEnergy = enSaddle - enInitial
        
        print 'Formation Energy:', formationEnergy
        print 'Migration Energy:', migrationEnergy
        sys.exit(0)
        
        return migrationEnergy, formationEnergy
    
    def _getUnitVector(self, vec):
        return vec / np.linalg.norm(vec)
        
    def _getAngle(self, vec1, vec2):
        # Get acute angle between two vectors in degrees (always between 0 - 90)
        vec1Unit = self._getUnitVector(vec1)
        vec2Unit = self._getUnitVector(vec2)
        angle = np.arccos(np.dot(vec1Unit, vec2Unit))
        if np.isnan(angle):
            return 0.0
        angle = angle * 180.0 / np.pi
        # if angle < 0:
            # return 180.0 + angle
        return angle
        
    def _getFit(self, xdata, ydata, orders):
        # Polynomial Fitting with Specific Orders
        A = []
        print '\nFit with Size:', xdata
        print 'Orders:', orders
        for order in orders:
            A.append(np.power(xdata * 1.0, -order))
        A = np.vstack(A).T
        print 'Matrix A (Ax = y):\n', A
        print 'Data for Fitting:', ydata
        res = np.linalg.lstsq(A, ydata)
        print 'Fitting Results:', res
        return res[0]
        
    def _getValueUncert(self, valueFitId, uncertFitIds, systematicUncert, maxSizeId, dataSource):
        # Get sourceValue and sourceUncert use only certain size and fits
        # Get source value
        valueFitCnt = FITS_CNT[valueFitId]
        sourceValue = dataSource[valueFitId][maxSizeId - valueFitCnt + 1]
        
        # Get source uncertainty (statistical)
        sourceUncert = 0
        for uncertFitId in uncertFitIds:
            uncertFitCnt = FITS_CNT[uncertFitId]
            uncertValue = dataSource[uncertFitId][maxSizeId - uncertFitCnt + 1]
            sourceUncert = max([abs(uncertValue - sourceValue), sourceUncert])
        
        # Include systematic error, assuming independent of statistical errors
        sourceUncert = math.sqrt(sourceUncert**2 + systematicUncert**2)
        return sourceValue, sourceUncert
    
    def getResults(self):
        unitBulk = self.atoms
        unitCell = unitBulk.get_cell()
        
        # Calculate VME and VFE for Each Size
        sizes = []
        migrationEnergyBySize = []
        formationEnergyBySize = []
        print '\n[Calculation]'
        for size in range(self.cellSizeMin, self.cellSizeMax + 1):
            migrationEnergy, formationEnergy = self._getResultsForSize(size)
            sizes.append(size)
            migrationEnergyBySize.append(migrationEnergy)
            formationEnergyBySize.append(formationEnergy)
        
        print '\n[Calculation Results Summary]'
        print 'Size\tMigrationEnergy\tFormationEnergy'
        for i in range(len(sizes)):
            print '\t'.join([sizes[i], migrationEnergy[i], formationEnergy[i]])
        
        sys.exit(0)
        
        # Data for skipping computation when debugging extrapolation and output
        # sizes = [3, 4, 5, 6, 7, 8, 9]
        # formationEnergyBySize = [
                # 0.6721479768766585 ,
                # 0.67372899358906579,
                # 0.67440913973746319,
                # 0.6747228089247983 ,
                # 0.67488432759455463,
                # 0.6749755557248136 ,
                # 0.67503091578691965,
        # ]
        # relaxationVolumeBySize = [
                # 8.2664887840680876, 
                # 8.2145358736270282, 
                # 8.2008345712674782, 
                # 8.1943833508903481, 
                # 8.1916426682910242, 
                # 8.1898981954873307, 
                # 8.1889297673697001,
        # ]
        
        # Extrapolate for VFE and VRV of Infinite Size
        print '\n[Extrapolation]'
        naSizes = np.array(sizes)
        naFormationEnergyBySize = np.array(formationEnergyBySize)
        naRelaxationVolumeBySize = np.array(relaxationVolumeBySize)
        formationEnergyFitsBySize = []
        relaxationVolumeFitsBySize = []
        for i in range(0, len(FITS_CNT)):
            cnt = FITS_CNT[i] # Num of Data Points Used
            orders = FITS_ORDERS[i] # Orders Included
            print 'Fitting with', cnt, 'points, including orders', orders
            formationEnergyFits = []
            relaxationVolumeFits = []
            for j in range(0, len(sizes) - cnt + 1):
                print 'Fit with data beginning', j
                xdata = naSizes[j:(j + cnt)]
                formationEnergyFits.append(self._getFit(
                    xdata, 
                    naFormationEnergyBySize[j:(j + cnt)], 
                    orders
                )[0])
                relaxationVolumeFits.append(self._getFit(
                    xdata,
                    naRelaxationVolumeBySize[j:(j + cnt)],
                    orders
                )[0])
            formationEnergyFitsBySize.append(formationEnergyFits)
            relaxationVolumeFitsBySize.append(relaxationVolumeFits)
        
        # Output Fitting Results
        print '\n[Fitting Results Summary]'
        print 'Sizes:', sizes
        print 'Data Points Used:', FITS_CNT
        print 'Orders Included:\n', np.array(FITS_ORDERS)
        print 'Formation Energy Fits By Size:\n', np.array(formationEnergyFitsBySize)
        print 'Relaxation Volume Fits By Size:\n', np.array(relaxationVolumeFitsBySize)
        
        # Obtain Extrapolated Value and Uncertainty
        formationEnergy, formationEnergyUncert = self._getValueUncert(
            FITS_VFE_VALUE,
            FITS_VFE_UNCERT,
            FMIN_FTOL * formationEnergyBySize[-1],
            2,
            formationEnergyFitsBySize,
        )
        relaxationVolume, relaxationVolumeUncert = self._getValueUncert(
            FITS_VRV_VALUE,
            FITS_VRV_UNCERT,
            FMIN_XTOL * (self.latticeConsts[0] * CELL_SIZE_MAX)**3,
            2,
            relaxationVolumeFitsBySize,
        )
        
        # Construct Results Dictionary
        formationEnergyResult = OrderedDict([
            ('property-id', VFE_PROP_ID),
            ('instance-id', 1),
            ('relaxed-formation-potential-energy', V(formationEnergy, UNIT_ENERGY, formationEnergyUncert)),
        ])
        relaxationVolumeResult = OrderedDict([
            ('property-id', VRV_PROP_ID),
            ('instance-id', 2),
            ('relaxation-volume', V(relaxationVolume, UNIT_VOLUME, relaxationVolumeUncert)),
        ])
        hostInfo = OrderedDict([
            ('host-cauchy-stress', V([0, 0, 0, 0, 0, 0], UNIT_PRESSURE)),
            ('host-removed-atom', V(1)),
            ('host-short-name', V([self.lattice])),
            ('host-a', V(np.linalg.norm(unitCell[0]), UNIT_LENGTH)),
            ('host-b', V(np.linalg.norm(unitCell[1]), UNIT_LENGTH)),
            ('host-c', V(np.linalg.norm(unitCell[2]), UNIT_LENGTH)),
            ('host-alpha', V(self._getAngle(unitCell[1], unitCell[2]), UNIT_ANGLE)),
            ('host-beta', V(self._getAngle(unitCell[2], unitCell[0]), UNIT_ANGLE)),
            ('host-gamma', V(self._getAngle(unitCell[0], unitCell[1]), UNIT_ANGLE)),
            ('host-space-group', V(SPACE_GROUPS[self.lattice])),
            ('host-wyckoff-multiplicity-and-letter', V(WYCKOFF_CODES[self.lattice])),
            ('host-wyckoff-coordinates', V(WYCKOFF_SITES[self.lattice])),
            ('host-wyckoff-species', V([self.elem] * len(WYCKOFF_CODES[self.lattice]))),
        ])
        reservoirInfo = OrderedDict([
            ('reservoir-cohesive-potential-energy', V(unitBulk.get_potential_energy(), UNIT_ENERGY)),
            ('reservoir-short-name', V([self.lattice])),
            ('reservoir-cauchy-stress', V([0.0, 0.0, 0.0, 0.0, 0.0, 0.0], UNIT_PRESSURE)),
            ('reservoir-a', V(np.linalg.norm(unitCell[0]), UNIT_LENGTH)),
            ('reservoir-b', V(np.linalg.norm(unitCell[1]), UNIT_LENGTH)),
            ('reservoir-c', V(np.linalg.norm(unitCell[2]), UNIT_LENGTH)),
            ('reservoir-alpha', V(self._getAngle(unitCell[1], unitCell[2]), UNIT_ANGLE)),
            ('reservoir-beta', V(self._getAngle(unitCell[2], unitCell[0]), UNIT_ANGLE)),
            ('reservoir-gamma', V(self._getAngle(unitCell[0], unitCell[1]), UNIT_ANGLE)),
            ('reservoir-space-group', V(SPACE_GROUPS[self.lattice])),
            ('reservoir-wyckoff-multiplicity-and-letter', V(WYCKOFF_CODES[self.lattice])),
            ('reservoir-wyckoff-coordinates', V(WYCKOFF_SITES[self.lattice])),
            ('reservoir-wyckoff-species', V([self.elem] * len(WYCKOFF_CODES[self.lattice]))),
        ])
        
        formationEnergyResult.update(hostInfo)
        formationEnergyResult.update(reservoirInfo)
        relaxationVolumeResult.update(hostInfo)
        
        results = [formationEnergyResult, relaxationVolumeResult]
        return results

def V(value, unit = '', uncert = ''):
    # Generate OrderedDict for JSON Dump
    res = OrderedDict([
        (KEY_SOURCE_VALUE, value),
    ])
    if unit != '':
        res.update(OrderedDict([
            (KEY_SOURCE_UNIT, unit),
        ]))
    if uncert != '':
        res.update(OrderedDict([
            (KEY_SOURCE_UNCERT, uncert)
        ]))
    return res

def main():
    # Create Environment and Common Variables
    # If it's hcp crystal, process both a and c
    # Otherwise, process a, ignore c
    if lattice == 'hcp':
        latticeConsts = [float(latticeConstA), float(latticeConstC)]
    else:
        latticeConsts = [float(latticeConstA)]
    calc = KIMCalculator(model)
    print 'Parameters Input:', elem, lattice, model, latticeConsts
    
    # Create Instance
    instance = VacancyCalculation(calc, elem, model, lattice, latticeConsts)
    
    # Obtain Results
    res = instance.getResults()
    
    # Output results
    print '\n[Final Results]'
    resStr = json.dumps(res, separators = (' ',' '), indent = 4)
    print resStr
    with open(os.path.abspath('output/results.edn'), 'w') as f:
        f.write(resStr)

if __name__ == '__main__':
    main()