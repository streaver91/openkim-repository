#!/usr/bin/env python
"""
Universal test to check aperiodic boundary conditions
"""
try:
    from ase.lattice import bulk # For ASE version 3.9
except ImportError:
    from ase.structure import bulk # For ASE version <= 3.8
from kimcalculator import KIMCalculator
import kimservice as ks
from string import Template
import itertools
import numpy as np

def get_species(model, q=None):
    """ Attempt to read the speices of the model """
    status, pkim = ks.KIM_API_model_info(model)
    ks.KIM_API_get_NBC_method(pkim)
    nspecies = ks.KIM_API_get_num_model_species(pkim)
    return [ks.KIM_API_get_model_species(pkim, i) for i in xrange(nspecies)]

list_nbcs = [
    "NEIGH_RVEC_F", "NEIGH_RVEC_H",
    "NEIGH_PURE_F", "NEIGH_PURE_H",
    "MI_OPBC_F", "MI_OPBC_H"
]

# structures = [
    # "sc", "fcc", "bcc", "diamond",
# ]
structures = ["fcc"]

def template_descriptor(species, nbc, iterloca):
    with open("./descriptor.kim") as f:
        kimstr = f.read()
    with open("./temp-descriptor.kim", 'w') as f:
        f.write(
            Template(kimstr).substitute(
                species=species, iterloca=iterloca, nbc=nbc
            )
        )

def generate_slab(species, struct, N=3):
    slab = bulk(species, struct, cubic=True)
    slab = slab.repeat((N,N,N))
    slab.rattle(stdev=0.3)

    L = slab.get_cell()[0,0]
    p = slab.get_positions()
    slab.set_positions(np.clip(p, 0, L))
    return slab

def run_energy(slab, nbc=None, iterloca=None):
    template_descriptor(slab.get_chemical_symbols()[0], nbc, iterloca)

    factor = 1
    calc = KIMCalculator(model, kimfile='./temp-descriptor.kim')
    slab.set_calculator(calc)

    if "PURE" in nbc:
        N = len(slab)

        slab = slab.repeat((3,3,3))
        p = slab.get_positions()
        copy = np.copy(p)

        p[0:N] = copy[13*N:13*N+N]
        p[N:14*N] = copy[0:13*N]
        p[14*N:] = copy[14*N:]

        slab.set_positions(p)
        ghosts = np.ones(len(slab), dtype='int32')
        ghosts[:N] = 0
        
        #print len(slab)-ghosts.sum(), N
        slab.set_calculator(calc)
        calc.set_ghosts(ghosts)

    if "OPBC" in nbc:
        repeat = (3,3,3)
        slab = slab.repeat(repeat)
        slab.set_calculator(calc)
        factor = np.prod(repeat)

    return -slab.get_potential_energy()/factor

if __name__ == "__main__":
    #model = raw_input("modelname = ")
    #model = "MEAM_2NN_Fe_to_Ga__MO_145522277939_001"
    model = "EAM_Dynamo_Mishin_Farkas_Al__MO_651801486679_001"
    #model = "model_Fe_PF_chiesa_quinticsplines__MO_140444321607_001"
    #model = "Pair_Morse_Shifted_GirifalcoWeizer_MedCutoff_Cr__MO_245813471114_001"
    #model = "Three_Body_Stillinger_Weber_Balamane_Si__MO_113686039439_001"
    #model = "Tersoff_LAMMPS_Erhart_Albe_CSi__MO_903987585848_001"
    #model = 'EDIP_BOP_Bazant_Kaxiras_Si__MO_958932894036_001'

    #model = raw_input("Enter modelname = ")

    species = get_species(model)
    print "Running for species %r" % species
    
    result = {}
    for (sp,struct) in itertools.product(species, structures):
        slab = generate_slab(sp, struct, 3)
        for nbc in list_nbcs:
            print "Running", sp, struct, nbc
            try:
                energy = run_energy(slab, nbc=nbc)
            except Exception as e:
                energy = "<none>"
            result[(sp,struct,nbc)] = (len(slab), energy)

    for (sp,struct) in itertools.product(species, structures):
        slab = generate_slab(sp, struct)
        print "Using %i atoms..." % len(slab)

        for nbc in list_nbcs:
            ll, energy = result[(sp, struct, nbc)]
            print sp,'\t', struct, '\t', nbc, '\t', energy